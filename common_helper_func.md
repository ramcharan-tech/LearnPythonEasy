# Core built-in helpers (super common in DSA)

| Method / Operation                             | What it does                                     | Example                                               | Special errors / corner cases                                                                                         |
| ---------------------------------------------- | ------------------------------------------------ | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `range(stop)` / `range(start, stop[, step])`   | Lazy sequence of integers (often used in loops). | `for i in range(0, n, 2): ...`                        | `step` cannot be `0` (`ValueError`); very large ranges are fine (lazy) but converting to list uses memory.            |
| `enumerate(iterable, start=0)`                 | Iterate with index and value.                    | `for i, x in enumerate(arr): ...`                     | Index is an int counter, independent of iterable’s type; no special errors.                                           |
| `sorted(iterable, *, key=None, reverse=False)` | Return new sorted list.                          | `sorted(arr)`; `sorted(words, key=len, reverse=True)` | Elements must be comparable under key; mixing incomparable types (e.g. `int` and `str`) → `TypeError`.                |
| `reversed(seq)`                                | Iterator over sequence in reverse order.         | `for x in reversed(arr): ...`                         | Works on sequences & objects implementing `__reversed__`; for general iterables use `reversed(list(iterable))`.       |
| `zip(*iterables)`                              | Pair up items by index (shortest length).        | `for a,b in zip(A,B): ...`                            | Stops at shortest iterable; for unequal lengths, tail of longer ones is ignored.                                      |
| `map(func, *iterables)`                        | Apply function elementwise; returns iterator.    | `map(lambda x:x*x, arr)`                              | Stops at shortest iterable if multiple; `func` must accept as many args as iterables; exceptions in `func` propagate. |
| `filter(func, iterable)`                       | Keep items where `func(item)` is true.           | `filter(lambda x:x%2==0, arr)`                        | If `func` is `None`, keeps truthy items; returns iterator.                                                            |
| `any(iterable)`                                | `True` if *any* element is truthy.               | `any(x>0 for x in arr)`                               | Short-circuits; empty iterable → `False`.                                                                             |
| `all(iterable)`                                | `True` if *all* elements are truthy.             | `all(x>=0 for x in arr)`                              | Short-circuits; empty iterable → `True`.                                                                              |
| `min(iterable, *, key=None, default=_)`        | Smallest element.                                | `min(arr)`, `min(arr, key=abs)`                       | `ValueError` for empty iterable **unless** `default` is given; elements must be comparable under key.                 |
| `max(iterable, *, key=None, default=_)`        | Largest element.                                 | `max(arr)`, `max(points, key=lambda p:p[0])`          | Same behavior as `min` for empties & comparability.                                                                   |
| `sum(iterable, start=0)`                       | Sum of elements plus optional start.             | `sum(arr)`, `sum(arr, start=0)`                       | For floats, use `math.fsum` for high precision; don’t use with strings or general objects.                            |
| `len(obj)`                                     | Number of items.                                 | `len(arr)`, `len(graph[u])`                           | Works if object implements `__len__`; otherwise `TypeError`.                                                          |
| `list(iterable)`                               | Make list from iterable.                         | `arr = list(range(10))`                               | Consumes entire iterable; can be heavy for infinite/huge iterables.                                                   |
| `set(iterable)`                                | Make set (unique elements).                      | `seen = set(arr)`                                     | Elements must be hashable; unhashable (like lists) → `TypeError`.                                                     |
| `dict(pairs_or_mapping)`                       | Make dict from key–value pairs or mapping.       | `d = dict([('a',1), ('b',2)])`                        | Pairs must be 2-item iterables; duplicate keys → last one wins.                                                       |

# collections.namedtuple – lightweight struct type: from collections import namedtuple

| Method / Operation                                                               | What it does                                   | Example                                  | Special errors / corner cases                                                                                                                                        |
| -------------------------------------------------------------------------------- | ---------------------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)` | Create a new tuple subclass with named fields. | `Point = namedtuple('Point', ['x','y'])` | `field_names` can be list of strings or space-separated string; invalid names (keywords / duplicates) → `ValueError` unless `rename=True` (then they’re auto-fixed). |
| Create instance                                                                  | Make a record instance.                        | `p = Point(2, 3)`                        | Like tuple: fixed length; too many/few args → `TypeError`.                                                                                                           |
| Attribute access                                                                 | Access fields by name.                         | `p.x`, `p.y`                             | Fields are read-only (immutable); assignment `p.x = 5` → `AttributeError`.                                                                                           |
| Tuple behavior                                                                   | Works like a tuple too.                        | `p[0]  # 2`, `x, y = p`                  | Compared and hashed by contents; safe to use as dict keys or set elements.                                                                                           |
| `_fields`                                                                        | Tuple of field names.                          | `Point._fields  # ('x','y')`             | Introspection only.                                                                                                                                                  |
| `_replace(**kwargs)`                                                             | Return new instance with some fields changed.  | `p2 = p._replace(x=10)`                  | Old instance unchanged; invalid field name in kwargs → `ValueError`.                                                                                                 |
| `_asdict()`                                                                      | Return `OrderedDict` of field→value.           | `p._asdict()`                            | Useful for debugging / serialization.                                                                                                                                |
| `typename._make(iterable)`                                                       | Create instance from iterable.                 | `Point._make([2,3])`                     | Length of iterable must match field count; otherwise `TypeError`.                                                                                                    |
| Use in DSA                                                                       | Use for edges, states, etc.                    | `Edge = namedtuple('Edge', 'u v w')`     | Very memory-efficient vs custom class; immutable (so great for keys).                                                                                                |

# queue.PriorityQueue – thread-safe priority queue
You already know heapq; this is a thread-safe wrapper over a heap

| Method / Operation                       | What it does                                      | Example                                | Special errors / corner cases                                                                                                                                            |
| ---------------------------------------- | ------------------------------------------------- | -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `PriorityQueue(maxsize=0)`               | Create a thread-safe min-priority queue.          | `pq = PriorityQueue()`                 | `maxsize <= 0` → infinite capacity; positive `maxsize` → `put` may block if full.                                                                                        |
| `pq.put(item, block=True, timeout=None)` | Insert `item`; blocks if full and `block=True`.   | `pq.put((dist, node))`                 | If `block=False` and full → `queue.Full`; with `timeout` and still full → `queue.Full`. Items must be comparable (if not using a tuple `(priority, tie_breaker, data)`). |
| `pq.put_nowait(item)`                    | Non-blocking put.                                 | `pq.put_nowait((1, 'task'))`           | Equivalent to `put(..., block=False)`; `queue.Full` if full.                                                                                                             |
| `pq.get(block=True, timeout=None)`       | Remove and return smallest item; blocks if empty. | `priority, node = pq.get()`            | If `block=False` and empty → `queue.Empty`; with `timeout` and still empty → `queue.Empty`.                                                                              |
| `pq.get_nowait()`                        | Non-blocking get.                                 | `item = pq.get_nowait()`               | Same as `get(..., block=False)`; `queue.Empty` if empty.                                                                                                                 |
| `pq.qsize()`                             | Approximate number of items.                      | `n = pq.qsize()`                       | In multi-threaded code, it’s only approximate (race conditions).                                                                                                         |
| `pq.empty()`                             | True if queue is (probably) empty.                | `if pq.empty(): ...`                   | Can be false immediately after check (another thread inserts).                                                                                                           |
| `pq.full()`                              | True if queue is (probably) full.                 | `if pq.full(): ...`                    | Same race condition caveat.                                                                                                                                              |
| `pq.task_done()`                         | Indicate that `get()`’s task is complete.         | `item = pq.get(); ...; pq.task_done()` | Calling more times than items fetched by `get()` → `ValueError`.                                                                                                         |
| `pq.join()`                              | Block until all enqueued tasks are marked done.   | `pq.join()`                            | Requires matching `task_done()` for each `put()`; otherwise `join()` never returns.                                                                                      |

# copy – shallow & deep copy of structures
Very handy so your algorithm doesn’t accidentally mutate shared structures
import copy

| Method / Operation                | What it does                            | Example                             | Special errors / corner cases                                                                                                                                                   |
| --------------------------------- | --------------------------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `copy.copy(x)`                    | Shallow copy of object.                 | `b = copy.copy(a)`                  | Container object is new, but **inner elements are the same objects** (shared). Mutating nested structures affects both.                                                         |
| `copy.deepcopy(x, memo=None)`     | Deep copy: recursively copy objects.    | `b = copy.deepcopy(a)`              | Follows references recursively; can be slow or hit recursion if structure has cycles; `memo` used internally to avoid infinite loops on self-referential objects.               |
| Custom `__copy__`, `__deepcopy__` | Classes can define how copy works.      | `python\ndef __copy__(self): ...`   | If defined incorrectly, your objects might not copy as you expect (e.g. sharing state unintentionally).                                                                         |
| When to use (DSA)                 | Duplicate graphs, trees, states safely. | `next_state = copy.deepcopy(state)` | In contests, prefer writing algorithms that don’t need deep copy (for speed), but it’s very useful in backtracking or search when correctness is more important than raw speed. |
| Assignment vs copy                | `b = a` just binds name; no copying.    | `b = a`                             | Both names reference same object; mutating through one affects the other—classic bug when using lists/dicts for DP tables.                                                      |

# timeit – quick performance measurement
Perfect for checking which of two solutions is faster.
import timeit

| Method / Operation                                                                          | What it does                                                | Example                                                                                | Special errors / corner cases                                                                                                                                    |
| ------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `timeit.timeit(stmt='pass', setup='pass', timer=<default>, number=1_000_000, globals=None)` | Run `stmt` `number` times and return total time in seconds. | `t = timeit.timeit('sum(range(100))', number=10000)`                                   | `stmt` and `setup` are strings (or callables in newer usage); code runs in its own namespace unless you pass `globals`. Big `number` → more accurate but slower. |
| `timeit.repeat(stmt, setup, timer, repeat=5, number=1_000_000, globals=None)`               | Run `timeit` multiple times and return list of times.       | `times = timeit.repeat('f()', setup='from __main__ import f', repeat=5, number=10000)` | Helps see variance; often use `min(times)` as best estimate. May run for quite long if `repeat` and `number` large.                                              |
| `timeit.Timer(stmt='pass', setup='pass', timer=<default>)`                                  | Lower-level timer object.                                   | `timer = timeit.Timer('f()', 'from __main__ import f')`                                | You can call `timer.timeit(number)` or `timer.repeat(...)` later; similar caveats on namespace and strings.                                                      |
| CLI usage                                                                                   | Run from command line.                                      | `python -m timeit "sum(range(100))"`                                                   | Command-line options `-n`, `-r`, `-s` control number, repeats, setup; good for quick experiments.                                                                |
| GC handling                                                                                 | `timeit` disables garbage collector by default.             | `timeit.timeit(...)`                                                                   | This avoids GC “noise” but may not match real-world behavior exactly if your code allocates a lot.                                                               |
| When to use (DSA)                                                                           | Compare two implementations.                                | Measure `O(n)` vs `O(n log n)` on different input sizes.                               | Always run on multiple input sizes; don’t assume small `n` timings reflect asymptotic performance.                                                               |


