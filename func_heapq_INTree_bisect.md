# heapq (min-heap / priority queue)

| Method / Operation                                                                                        | What it does                                                                           | Example                                            | Special errors / corner cases                                                                                                                |
| --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `heapq.heapify(x)`                                                                                        | In-place transform list `x` into a min-heap.                                           | `h = [3,1,4]; heapq.heapify(h)`                    | `x` must be a mutable sequence; elements must be mutually comparable or you’ll get `TypeError`. ([Python documentation][1])                  |
| `heapq.heappush(heap, item)`                                                                              | Push `item` onto heap while keeping heap invariant.                                    | `heapq.heappush(h, 2)`                             | Same comparability requirement; mixing `str` and `int` in Python 3 → `TypeError`.                                                            |
| `heapq.heappop(heap)`                                                                                     | Pop and return smallest item (`heap[0]`).                                              | `small = heapq.heappop(h)`                         | `IndexError` if heap is empty. ([Python documentation][1])                                                                                   |
| `heapq.heappushpop(heap, item)`                                                                           | Push `item` then pop and return smallest item (more efficient than separate push+pop). | `x = heapq.heappushpop(h, 10)`                     | On average faster than `heappush` then `heappop`; still needs comparable elements.                                                           |
| `heapq.heapreplace(heap, item)`                                                                           | Pop and return smallest, then push `item` (always pushes, even if bigger).             | `x = heapq.heapreplace(h, 10)`                     | `IndexError` if heap empty; differs from `heappushpop` when `item` is smaller than current min.                                              |
| `heapq.merge(*iterables, key=None, reverse=False)`                                                        | Merge multiple already-sorted iterables, yielding items in sorted order.               | `for x in heapq.merge(a, b): ...`                  | Inputs must each be sorted; otherwise result is not globally sorted. Works as a generator, not a heap structure. ([Python documentation][1]) |
| `heapq.nsmallest(n, iterable, key=None)`                                                                  | Return list of `n` smallest elements.                                                  | `heapq.nsmallest(3, data)`                         | For small `n` uses a heap; for large `n` may internally sort (O(m log m)). ([Python documentation][1])                                       |
| `heapq.nlargest(n, iterable, key=None)`                                                                   | Return list of `n` largest elements.                                                   | `heapq.nlargest(2, data, key=len)`                 | Same performance caveats as `nsmallest`.                                                                                                     |
| **Peek smallest element**                                                                                 | Read smallest item without popping.                                                    | `min_val = h[0]`                                   | `IndexError` if heap is empty. Also, this doesn’t validate heap property; you must have used `heapify`/`heappush`.                           |
| **Max-heap helpers** (`heapify_max`, `heappush_max`, `heappop_max`, `heapreplace_max`, `heappushpop_max`) | Variant API treating list as max-heap (largest at index 0).                            | `heapq.heapify_max(h); top = heapq.heappop_max(h)` | Only in newer Python versions (3.13+); check your Python version before relying on them. ([Python documentation][1])                         |
| **Use tuples for priorities**                                                                             | Implement priority queues with extra payloads.                                         | `heapq.heappush(h, (priority, task))`              | Tie-break order is by later tuple items; if second items aren’t comparable you can still get `TypeError`.                                    |

[1]: https://docs.python.org/3/library/heapq.html "heapq — Heap queue algorithm — Python 3.14.1 documentation"

# treelib – Tree and Node

## Core Tree operations

| Method / Operation                                               | What it does                                                  | Example                                           | Special errors / corner cases                                                                                                                                                                      |
| ---------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Tree()`                                                         | Create an empty tree.                                         | `tree = Tree()`                                   | Tree has no root until you add one. ([treelib.readthedocs.io][1])                                                                                                                                  |
| `tree.create_node(tag, identifier=None, parent=None, data=None)` | Create a `Node` and add it to the tree.                       | `tree.create_node("Root", "root")`                | `DuplicatedNodeIdError` if `identifier` already exists; `MultipleRootError` if `parent=None` but root already set; `NodeIDAbsentError` if `parent` id doesn’t exist. ([treelib.readthedocs.io][1]) |
| `tree.add_node(node, parent=None)`                               | Add an existing `Node` instance.                              | `tree.add_node(Node("Child","c"), parent="root")` | Same errors as above, plus `OSError` if `node` is wrong type. ([treelib.readthedocs.io][1])                                                                                                        |
| `tree.children(nid)`                                             | Direct children `Node` objects of a node id.                  | `kids = tree.children("root")`                    | `NodeIDAbsentError` if `nid` not in tree.                                                                                                                                                          |
| `tree.parent(nid)`                                               | Parent node of `nid`.                                         | `p = tree.parent("a1")`                           | `None` if node is root; `NodeIDAbsentError` if `nid` missing.                                                                                                                                      |
| `tree.ancestors(nid)`                                            | List of ancestor nodes up to root.                            | `anc = tree.ancestors("a1")`                      | Empty list if `nid` is root.                                                                                                                                                                       |
| `tree.descendants(nid)`                                          | All descendants of node.                                      | `desc = tree.descendants("root")`                 | Can be large; be careful in huge trees.                                                                                                                                                            |
| `tree.subtree(nid)`                                              | Return a new `Tree` representing the subtree rooted at `nid`. | `sub = tree.subtree("eng")`                       | New tree has its own root; node ids reused; modifications don’t affect original. ([treelib.readthedocs.io][1])                                                                                     |
| `tree.move_node(nid, new_parent)`                                | Move a node (and its subtree) to a new parent.                | `tree.move_node("alice", "sales")`                | `NodeIDAbsentError` if `nid`/`new_parent` missing; may raise if it would create a cycle. ([treelib.readthedocs.io][1])                                                                             |
| `tree.remove_node(nid)`                                          | Remove node and all its descendants.                          | `tree.remove_node("eng")`                         | Removing root empties the tree. Raises if `nid` not found.                                                                                                                                         |
| `tree.show()`                                                    | Pretty-print tree to stdout.                                  | `tree.show()`                                     | Pure visualization; for wide/deep trees output can be big. ([treelib.readthedocs.io][1])                                                                                                           |
| `tree.expand_tree(nid=None, mode=Tree.DEPTH, ...)`               | Generator of node ids in DFS/BFS/zigzag order.                | `for nid in tree.expand_tree(): ...`              | Use constants `Tree.ROOT`, `Tree.DEPTH`, `Tree.WIDTH`, `Tree.ZIGZAG`. Large trees → many results. ([treelib.readthedocs.io][1])                                                                    |
| `tree.leaves(nid=None)`                                          | Return leaf nodes (no children), whole tree or under `nid`.   | `leaves = tree.leaves()`                          | For big trees can be O(n).                                                                                                                                                                         |
| `tree.depth(nid=None)`                                           | Depth of tree or a given node.                                | `d = tree.depth()`                                | Different from `tree.level(nid)` (distance from root).                                                                                                                                             |
| `tree.level(nid)`                                                | Level of node from root (root is 0).                          | `level = tree.level("alice")`                     | `NodeIDAbsentError` if node missing. ([treelib.readthedocs.io][1])                                                                                                                                 |
| `tree.to_dict() / Tree.from_dict()`                              | Serialize / rebuild tree as nested dict.                      | `data = tree.to_dict()`                           | Custom data payload may need to be JSON-serializable if you later convert to JSON.                                                                                                                 |
| `tree.to_json() / Tree.from_json()`                              | JSON export / import.                                         | `js = tree.to_json()`                             | Same serialization caveats as above.                                                                                                                                                               |
| Indexing: `tree[nid]`                                            | Get `Node` by identifier (mapping-like access).               | `node = tree["alice"]`                            | `KeyError`/`NodeIDAbsentError` if id not present.                                                                                                                                                  |

[1]: https://treelib.readthedocs.io/en/latest/treelib.html "treelib package — treelib 1.8.0 documentation"
## Common Node helpers

| Method / Operation                                     | What it does                                                  | Example                                          | Special errors / corner cases                                                                                |
| ------------------------------------------------------ | ------------------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |
| `Node(tag, identifier, expanded=True, data=None)`      | Create a standalone node (usually added via `Tree.add_node`). | `n = Node("User", "u1", data={"age": 20})`       | Usually safer to use `Tree.create_node` so parent/child relations are managed. ([treelib.readthedocs.io][1]) |
| Attributes: `node.tag`, `node.identifier`, `node.data` | Access label, id, and payload.                                | `print(node.tag, node.identifier)`               | Id must be unique per tree; tag does not. ([treelib.readthedocs.io][1])                                      |
| `node.is_leaf(tree_id=None)`                           | True if node has no children in that tree.                    | `node.is_leaf(tree._identifier)`                 | Tree id is internal; when using via `Tree` you usually call `tree.leaves()`. ([treelib.readthedocs.io][1])   |
| `node.is_root(tree_id=None)`                           | True if node has no parent in that tree.                      | `node.is_root(tree._identifier)`                 | Same note as above. ([treelib.readthedocs.io][1])                                                            |
| `node.successors(tree_id)`                             | List of children ids.                                         | `node.successors(tree._identifier)`              | Internal, but useful if manipulating nodes directly.                                                         |
| `node.predecessor(tree_id)`                            | Parent id in given tree.                                      | `parent_id = node.predecessor(tree._identifier)` | `None` if this node is root.                                                                                 |

[1]: https://treelib.readthedocs.io/en/latest/treelib.html "treelib package — treelib 1.8.0 documentation"

# bisect (binary search in sorted lists)

| Method / Operation                                                               | What it does                                                           | Example                                                                        | Special errors / corner cases                                                                                                                                     |
| -------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `bisect.bisect_left(a, x, lo=0, hi=len(a), *, key=None)`                         | Find insertion index so that all items before are `< x`.               | `i = bisect.bisect_left(a, 10)`                                                | `a` must be sorted in the same order implied by comparisons (or `key`), otherwise result is meaningless. ([Python documentation][1])                              |
| `bisect.bisect_right(a, x, lo=0, hi=len(a), *, key=None)` / `bisect.bisect(...)` | Insertion index so that all items before are `<= x`.                   | `i = bisect.bisect(a, 10)`                                                     | Same sorted requirement; the two variants differ only in how they treat duplicates. ([Python documentation][1])                                                   |
| `bisect.insort_left(a, x, lo=0, hi=len(a), *, key=None)`                         | Insert `x` into sorted list `a` keeping order (before equal elements). | `bisect.insort_left(a, 10)`                                                    | `a` must already be sorted; insertion is O(n) even though search is O(log n). Not thread-safe on the same list from multiple threads. ([Python documentation][1]) |
| `bisect.insort_right(a, x, ...)` / `bisect.insort(...)`                          | Insert `x` after equal elements.                                       | `bisect.insort(a, 10)`                                                         | Same caveats as `insort_left`. ([Python documentation][1])                                                                                                        |
| Using `key` parameter                                                            | Compare using derived key rather than values directly.                 | `idx = bisect.bisect(movies, 1980, key=lambda m: m.year)`                      | `key` is only applied to list elements, **not** to `x` in `bisect_left/right` (see docs); same in `insort_*`. ([Python documentation][1])                         |
| “Index or fail” recipe                                                           | Build search helpers that raise on miss.                               | `i = bisect.bisect_left(a, x);`<br>`if i==len(a) or a[i]!=x: raise ValueError` | Official docs show these helpers; they’re not built-in functions. ([Python documentation][1])                                                                     |
| Common pitfall                                                                   | Forgetting to keep the list sorted while mutating.                     | `a.append(0); bisect.bisect(a, 5)`                                             | If you mutate `a` arbitrarily (e.g. `append` unsorted), bisect will silently return wrong indices.                                                                |

[1]: https://docs.python.org/3/library/bisect.html "bisect — Array bisection algorithm — Python 3.14.1 documentation"

# intervaltree.IntervalTree

## IntervalTree core operations

| Method / Operation                                                                                                      | What it does                                         | Example                                            | Special errors / corner cases                                                                                                     |                                                                                                                |
| ----------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `IntervalTree()`                                                                                                        | Create empty tree.                                   | `t = IntervalTree()`                               | Intervals are half-open: `[begin, end)` — include lower bound, exclude upper. ([GitHub][1])                                       |                                                                                                                |
| `IntervalTree(iterable_of_intervals)`                                                                                   | Build from `Interval` objects.                       | `t = IntervalTree([Interval(1,3), Interval(5,7)])` | Intervals must be `Interval` instances. ([GitHub][1])                                                                             |                                                                                                                |
| `IntervalTree.from_tuples(tuples)`                                                                                      | Build from `(begin, end[, data])` tuples.            | `t = IntervalTree.from_tuples([(1,3), (5,7,"x")])` | Tuples must be 2- or 3-length. ([GitHub][1])                                                                                      |                                                                                                                |
| `t[begin:end] = data`                                                                                                   | Add interval `[begin, end)` with payload `data`.     | `t[1:4] = "1-4"`                                   | Overwrites any previous interval with same range+data combination.                                                                |                                                                                                                |
| `t.add(interval)`                                                                                                       | Add an existing `Interval`.                          | `t.add(Interval(4,7,"A"))`                         | No error if overlapping another interval; tree supports overlaps. ([GitHub][1])                                                   |                                                                                                                |
| `t.addi(begin, end, data)`                                                                                              | Convenience to construct and add `Interval`.         | `t.addi(5,9,{5:9})`                                | Same semantics as `t.add(Interval(...))`. ([GitHub][1])                                                                           |                                                                                                                |
| `t.remove(interval)`                                                                                                    | Remove exact `Interval` object.                      | `t.remove(Interval(1,2,"1-2"))`                    | Raises `ValueError` if that exact interval is not in tree. ([GitHub][1])                                                          |                                                                                                                |
| `t.discard(interval)`                                                                                                   | Remove interval if present, do nothing otherwise.    | `t.discard(Interval(500,1000,"x"))`                | Never raises if not found. ([GitHub][1])                                                                                          |                                                                                                                |
| `removei(begin,end,data)` / `discardi(...)`                                                                             | Remove by components (internally builds `Interval`). | `t.removei(1,2,"1-2")`                             | `removei` raises `ValueError` if not present; `discardi` is silent. ([GitHub][1])                                                 |                                                                                                                |
| `t.remove_overlap(point)` / `t.remove_overlap(begin,end)`                                                               | Remove intervals overlapping a point or range.       | `t.remove_overlap(5, 10)`                          | Affects all overlapping intervals; easy to accidentally wipe more than intended. ([GitHub][1])                                    |                                                                                                                |
| `t.remove_envelop(begin,end)`                                                                                           | Remove intervals fully contained within range.       | `t.remove_envelop(5,20)`                           | Only intervals **inside** `[begin,end)` are removed. ([GitHub][1])                                                                |                                                                                                                |
| `t[point]` / `t.at(point)`                                                                                              | Query intervals covering `point`.                    | `hits = t[6]`                                      | Returns a `set` of `Interval`s → order is undefined; sort if needed. ([GitHub][1])                                                |                                                                                                                |
| `t[begin:end]` / `t.overlap(begin,end)`                                                                                 | Query intervals overlapping range.                   | `hits = t[1:5]`                                    | Overlap respects half-open semantics; `[2,4)` example in docs returns empty. ([GitHub][1])                                        |                                                                                                                |
| `t.envelop(begin,end)`                                                                                                  | Intervals completely inside the given range.         | `inner = t.envelop(1,5)`                           | Returns a `set`.                                                                                                                  |                                                                                                                |
| Membership: `interval in t`                                                                                             | O(1) membership by object identity.                  | `if iv in t: ...`                                  | Only works for same `Interval` object (or equal by value, per implementation). ([GitHub][1])                                      |                                                                                                                |
| `t.containsi(begin,end,data)`                                                                                           | Membership by components.                            | `t.containsi(1,2,"1-2")`                           | Returns bool.                                                                                                                     |                                                                                                                |
| `t.overlaps(point)` / `t.overlaps(begin,end)`                                                                           | Boolean overlap test.                                | `if t.overlaps(10,20): ...`                        | Uses same half-open rules as overlap queries. ([GitHub][1])                                                                       |                                                                                                                |
| Iteration: `for iv in t` / `t.items()`                                                                                  | Iterate over intervals.                              | `for iv in t: ...`                                 | Under the hood, this is a set-like collection — order not guaranteed.                                                             |                                                                                                                |
| Size / emptiness: `len(t)`, `t.is_empty()`, `not t`                                                                     | Tree size and emptiness checks.                      | `if not t: ...`                                    | `len` counts intervals, not distinct coordinates. ([GitHub][1])                                                                   |                                                                                                                |
| Bounds: `t.begin()`, `t.end()`                                                                                          | Global min `begin` and max `end`.                    | `start = t.begin()`                                | `ValueError` if tree is empty (implementation detail, but common). ([GitHub][1])                                                  |                                                                                                                |
| Set ops: `union`, `difference`, `intersection`, `symmetric_difference` and in-place `update`, `difference_update`, etc. | Treat trees like sets of intervals.                  | `u = t1.union(t2); t1                              | = t2`                                                                                                                             | Some methods return new trees, others modify in place; mixing many large trees can be expensive. ([GitHub][1]) |
| Comparisons: `issubset`, `issuperset`, `==`, `<=`, `>=`                                                                 | Compare interval sets.                               | `if t1 <= t2: ...`                                 | Comparison ignores ordering; only interval content matters. ([GitHub][1])                                                         |                                                                                                                |
| Restructuring: `chop`, `slice`, `split_overlaps`, `merge_overlaps`, `merge_equals`, `merge_neighbors`                   | Modify intervals (split, merge, etc.).               | `t.chop(3,7); t.merge_overlaps()`                  | These may modify `data` fields via callback; be sure you understand semantics before using in mutable shared trees. ([GitHub][1]) |                                                                                                                |
| Copy & conversion: `IntervalTree(t)`, `t.copy()`, `set(t)`, `list(t)`, `t.clear()`                                      | Duplicate or convert tree.                           | `t2 = t.copy(); t.clear()`                         | `IntervalTree(t)` reuses same Interval objects; `copy()` does shallow copies of intervals. ([GitHub][1])                          |                                                                                                                |

[1]: https://github.com/chaimleib/intervaltree "GitHub - chaimleib/intervaltree: A mutable, self-balancing interval tree. Queries may be by point, by range overlap, or by range containment."

# intervaltree.Interval

| Method / Operation                          | What it does                                          | Example                               | Special errors / corner cases                                                                                                                                 |
| ------------------------------------------- | ----------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Interval(begin, end, data=None)`           | Create interval `[begin, end)` with optional payload. | `iv = Interval(4, 7, "foo")`          | Library is designed for half-open intervals; negative or inverted ranges generally don’t make sense but aren’t always rejected at construction. ([GitHub][1]) |
| Attributes: `iv.begin`, `iv.end`, `iv.data` | Access endpoints and payload.                         | `print(iv.begin, iv.end, iv.data)`    | Just plain attributes; can be modified directly but that may break tree balancing if done while inside a tree. ([GitHub][1])                                  |
| Tuple unpacking                             | Intervals can be unpacked into `(begin, end, data)`.  | `b, e, d = iv`                        | If interval has no `data`, unpack usually yields `(begin, end, None)` (depends on version). ([GitHub][1])                                                     |
| String / repr                               | Nice printable form.                                  | `print(iv)` → `Interval(4, 7, 'foo')` | Helpful for debugging; not a functional API.                                                                                                                  |
| Use in sets / mapping keys                  | Intervals are hashable (so `set(t)` etc. works).      | `s = set(t)`                          | Equality and hashing are by `(begin, end, data)` so changing attributes after adding to a set/dict is dangerous. ([GitHub][1])                                |

[1]: https://github.com/chaimleib/intervaltree "GitHub - chaimleib/intervaltree: A mutable, self-balancing interval tree. Queries may be by point, by range overlap, or by range containment."

# pygtrie.Trie

| Method / Operation                                        | What it does                                                                | Example                                   | Special errors / corner cases                                                                                                                                |
| --------------------------------------------------------- | --------------------------------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Trie(*args, **kwargs)`                                   | Construct trie; args interpreted like `update`.                             | `t = Trie({'foo': 1, 'bar': 2})`          | Keys must be iterable and components hashable; for strings you generally want `StringTrie` for nicer key handling. ([pygtrie.readthedocs.io][1])             |
| `len(t)`                                                  | Number of **values** stored.                                                | `n = len(t)`                              | Potentially expensive (walks whole trie). ([pygtrie.readthedocs.io][1])                                                                                      |
| `t[key]` (`__getitem__`)                                  | Get value by key.                                                           | `val = t['foo']`                          | `KeyError` if no value and no prefix; `ShortKeyError` if key is a prefix of other keys but has no value. ([pygtrie.readthedocs.io][1])                       |
| `t[key] = value` (`__setitem__`)                          | Set value for key; or, with slice, replace whole subtrie.                   | `t['foo'] = 42`<br>`t['foo':] = 0`        | When using slice form, any previous subtree under that prefix is removed. Slice with non-`None` stop/step → `TypeError`. ([pygtrie.readthedocs.io][1])       |
| `del t[key]` / `del t[key:]` (`__delitem__`)              | Delete key or whole subtrie.                                                | `del t['foo']`<br>`del t['foo':]`         | `ShortKeyError` if key is prefix but has no value; `KeyError` if key doesn’t exist at all; slice with stop/step → `TypeError`. ([pygtrie.readthedocs.io][1]) |
| Membership: `key in t` / `t.has_key(key)`                 | True if key has a value.                                                    | `if 'foo' in t: ...`                      | Only checks node has a value, not just that it’s a prefix. ([pygtrie.readthedocs.io][1])                                                                     |
| `t.has_node(key)`                                         | Check whether a node exists and whether it has value / subtrie (bit flags). | `flags = t.has_node('foo')`               | Returns bitwise OR of `Trie.HAS_VALUE` and `Trie.HAS_SUBTRIE`; 0 if node doesn’t exist. ([pygtrie.readthedocs.io][1])                                        |
| `t.has_subtrie(key)`                                      | True if `key` is prefix of any key in trie.                                 | `t.has_subtrie('foo')`                    | `False` if node missing or has value but no children. ([pygtrie.readthedocs.io][1])                                                                          |
| `t.keys(prefix=_NoChildren, shallow=False)`               | List of keys with values, optionally limited by prefix.                     | `keys = t.keys(prefix='foo')`             | Raises `KeyError` if prefix node doesn’t exist. For plain `Trie`, keys are tuples; for `StringTrie` they’re strings. ([pygtrie.readthedocs.io][1])           |
| `t.items(prefix=..., shallow=False)` / `t.iteritems(...)` | Get `(key, value)` pairs or iterator.                                       | `for k,v in t.iteritems(): ...`           | `KeyError` if prefix doesn’t exist; order of siblings unspecified unless `enable_sorting(True)` called. ([pygtrie.readthedocs.io][1])                        |
| `t.iterkeys(...)`, `t.itervalues(...)`                    | Iterators over keys / values.                                               | `for k in t.iterkeys('foo'): ...`         | Same prefix and sorting behavior as `items`. ([pygtrie.readthedocs.io][1])                                                                                   |
| `t.clear()`                                               | Remove all values.                                                          | `t.clear()`                               | Leaves trie empty. ([pygtrie.readthedocs.io][1])                                                                                                             |
| `t.copy()`                                                | Shallow copy of trie.                                                       | `t2 = t.copy()`                           | Values are shared references (like dict’s `copy`). ([pygtrie.readthedocs.io][1])                                                                             |
| `Trie.fromkeys(keys, value=None)`                         | Classmethod: build trie with given keys all mapped to same value.           | `t = Trie.fromkeys(['a','b'], 0)`         | Keys interpreted as usual (iterables of components). ([pygtrie.readthedocs.io][1])                                                                           |
| `t.enable_sorting(enable=True)`                           | Control whether children are kept sorted during traversal.                  | `t.enable_sorting(True)`                  | Sorted traversal is slower; behavior differs slightly between `Trie` vs `StringTrie`. ([pygtrie.readthedocs.io][1])                                          |
| `t.longest_prefix(key)`                                   | Longest prefix of `key` that has a value.                                   | `step = t.longest_prefix('foo/bar/baz')`  | Returns a `_Step` object; falsy if no prefix. Can access `.key` and `.value`. ([pygtrie.readthedocs.io][1])                                                  |
| `t.shortest_prefix(key)`                                  | Shortest prefix of `key` that has a value.                                  | `step = t.shortest_prefix('foo/bar/baz')` | Similar `_Step` object behavior. ([pygtrie.readthedocs.io][1])                                                                                               |
| `t.prefixes(key)`                                         | Iterate over all prefixes of `key` that have values.                        | `list(t.prefixes('foo/bar/baz'))`         | Yields `_Step` objects from shortest to longest; returns empty sequence if none found. ([pygtrie.readthedocs.io][1])                                         |
| `t.setdefault(key, default=None)`                         | Like dict: get or create value.                                             | `v = t.setdefault('foo', 0)`              | Unlike `__setitem__`, does **not** accept slices. ([pygtrie.readthedocs.io][1])                                                                              |
| `t.pop(key, default=_NoChildren)`                         | Remove value and return it.                                                 | `v = t.pop('foo', 0)`                     | Without `default`, raises `KeyError` / `ShortKeyError` if no value; with default, those are suppressed. ([pygtrie.readthedocs.io][1])                        |
| `t.popitem()`                                             | Remove and return an arbitrary `(key, value)`.                              | `k,v = t.popitem()`                       | `KeyError` if trie is empty; no guarantee which key you get. ([pygtrie.readthedocs.io][1])                                                                   |
| `t.merge(other, overwrite=False)`                         | Merge another trie into this one (structural merge).                        | `t.merge(other, overwrite=True)`          | `other` is cleared after merge; some trie type combinations can’t be merged (may raise `TypeError`). ([pygtrie.readthedocs.io][1])                           |

[1]: https://pygtrie.readthedocs.io/en/latest/index.html "pygtrie — pygtrie  documentation"


