- itertools – iterators, combinatorics
- functools – memoization, custom sorting, functional tools
- operator – fast lambda replacements (itemgetter, etc.)
- random – randomness for algorithms / testing
- dataclasses – clean data containers for nodes / states

```
import itertools
import functools
import operator
import random
from dataclasses import dataclass, field, asdict, astuple, replace, is_dataclass, make_dataclass
```

# itertools – iterator / combinatorics toolbox
All of these return iterators, not lists. Most are in three groups: infinite, combinatoric, and “recipes”.

| Method/Operation                                                     | What it does                                                  | Example                                                                              | Special errors / corner cases                                                                   |
| -------------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- |
| `itertools.count(start=0, step=1)`                                   | Infinite counter: `start, start+step, ...`.                   | `for i in itertools.count(0, 2): ...`                                                | **Infinite** – must break manually or slice, or you’ll loop forever.                            |
| `itertools.cycle(iterable)`                                          | Infinite cycle over elements.                                 | `colors = itertools.cycle(['R','G','B'])`                                            | Also infinite; stores a copy of the iterable internally (memory!).                              |
| `itertools.repeat(object, times=None)`                               | Repeat `object` `times` or forever.                           | `list(itertools.repeat(1, 3))  # [1,1,1]`                                            | Infinite if `times` is `None`.                                                                  |
| `itertools.accumulate(iterable, func=operator.add, *, initial=None)` | Running accumulation (prefix sums/products/etc).              | `list(itertools.accumulate([1,2,3]))  # [1,3,6]`                                     | `func` must be a 2-arg function; `initial` adds one extra element at start.                     |
| `itertools.chain(*iterables)`                                        | Chain iterables end-to-end.                                   | `list(itertools.chain([1,2], [3]))  # [1,2,3]`                                       | Lazy; doesn’t copy data.                                                                        |
| `itertools.chain.from_iterable(iterable_of_iterables)`               | Flatten one level.                                            | `chain = itertools.chain.from_iterable(list_of_lists)`                               | Good when iterable-of-iterables comes from elsewhere.                                           |
| `itertools.compress(data, selectors)`                                | Filter `data` by boolean `selectors`.                         | `list(itertools.compress('ABCDE', [1,0,1,0,1]))  # ['A','C','E']`                    | Stops when either input is exhausted; selectors truthiness used.                                |
| `itertools.dropwhile(pred, iterable)`                                | Skip items while `pred(item)` true, then yield rest.          | `list(dropwhile(lambda x:x<3, [1,2,3,1]))  # [3,1]`                                  | Once predicate is false the first time, it’s never called again.                                |
| `itertools.takewhile(pred, iterable)`                                | Yield while `pred(item)` true, then stop.                     | `list(takewhile(lambda x<x<3, [1,2,3]))` → `[1,2]`                                   | Remaining items are **discarded**, not available later.                                         |
| `itertools.filterfalse(pred, iterable)`                              | Opposite of `filter`: keep items where `pred(item)` is false. | `list(filterfalse(lambda x:x%2, [1,2,3,4]))  # [2,4]`                                | If `pred` is `None`, keeps falsey items.                                                        |
| `itertools.islice(iterable, start, stop, step=1)`                    | Slice an iterator (like list slicing).                        | `list(islice(range(10), 2, 8, 2))  # [2,4,6]`                                        | Works on any iterable; once consumed, items are gone.                                           |
| `itertools.starmap(func, iterable_of_args)`                          | Like `map`, but unpacks args from tuples.                     | `list(starmap(pow, [(2,3),(3,2)]))  # [8,9]`                                         | Each element must be an iterable of arguments.                                                  |
| `itertools.zip_longest(*iterables, fillvalue=None)`                  | Zip to longest iterable; pad with `fillvalue`.                | `list(zip_longest('AB', '123', fillvalue='-'))` → `[('A','1'),('B','2'),('-', '3')]` | Beware of infinite iterables: zip_longest will be infinite too.                                 |
| `itertools.product(*iterables, repeat=1)`                            | Cartesian product.                                            | `list(product([1,2], ['a','b']))` → `[(1,'a'),(1,'b'),(2,'a'),(2,'b')]`              | Output size = `prod(len(it)*repeat)`; can blow up quickly.                                      |
| `itertools.permutations(iterable, r=None)`                           | All r-length permutations.                                    | `list(permutations([1,2,3], 2))`                                                     | Size ≈ `n!` if `r` not given → expensive fast.                                                  |
| `itertools.combinations(iterable, r)`                                | r-length combinations (no order, no repetition).              | `list(combinations('ABC', 2))`                                                       | Size = `nCr`; again can be large.                                                               |
| `itertools.combinations_with_replacement(iterable, r)`               | r-combinations allowing repeated elements.                    | `list(combinations_with_replacement('AB', 2))` → `[('A','A'),('A','B'),('B','B')]`   | Size = `nCr_r` (with repetition); can grow fast.                                                |
| `itertools.groupby(iterable, key=None)`                              | Group consecutive equal elements (by `key`).                  | `[(k, list(g)) for k,g in groupby('aaabb', key=lambda x:x)]`                         | **Only groups consecutive runs**; data must be pre-sorted by key for value-based grouping.      |
| `itertools.pairwise(iterable)`                                       | Overlapping pairs `(a0,a1), (a1,a2), ...`.                    | `list(pairwise([1,2,3,4]))  # [(1,2),(2,3),(3,4)]`                                   | Added in 3.10; don’t use if you need to support much older Pythons. ([Python documentation][1]) |
| `itertools.batched(iterable, n)`                                     | Yield fixed-size chunks (last may be smaller).                | `list(batched(range(7), 3))  # [(0,1,2),(3,4,5),(6,)]`                               | Added in 3.12; `n <= 0` raises `ValueError`. ([Python documentation][1])                        |

[1]: https://docs.python.org/3/library/itertools.html?utm_source=chatgpt.com "itertools — Functions creating iterators for efficient looping — Python ..."

# functools – higher-order helpers & memoization

Very handy for DP/memoization and custom sorting

| Method/Operation                                          | What it does                                                                       | Example                                                                                    | Special errors / corner cases                                                                                                                   |
| --------------------------------------------------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `@functools.lru_cache(maxsize=128, typed=False)`          | Memoize function results with LRU eviction.                                        | `python\n@functools.lru_cache(None)\ndef fib(n): return n if n<2 else fib(n-1)+fib(n-2)\n` | Arguments must be hashable; use `maxsize=None` for unbounded cache; `typed=True` treats `1` and `1.0` as different keys.                        |
| `@functools.cache`                                        | Unbounded cache (like `lru_cache(maxsize=None)`).                                  | `@functools.cache\ndef f(x): ...`                                                          | No LRU: memory can grow indefinitely if many distinct argument combos. ([Python documentation][1])                                              |
| `functools.reduce(func, iterable, initializer=_sentinel)` | Fold iterable into single value.                                                   | `reduce(lambda a,b:a+b, [1,2,3], 0)  # 6`                                                  | For empty iterable **without** `initializer` → `TypeError`. With initializer, result is initializer for empty iterable.                         |
| `functools.cmp_to_key(cmp)`                               | Convert old-style `cmp(a,b)` into `key` function for `sort` / `sorted`.            | `sorted(arr, key=cmp_to_key(cmp_func))`                                                    | `cmp` must return negative/zero/positive; misuse can break sort invariants.                                                                     |
| `functools.partial(func, *args, **kwargs)`                | Freeze some args, returning new function.                                          | `inc = partial(lambda x,y:x+y, 1)`                                                         | New function still checks argument counts; mis-matching leftover args → `TypeError`.                                                            |
| `functools.wraps(wrapped)`                                | Decorator to copy metadata to wrapper.                                             | `python\n@functools.wraps(func)\ndef wrapper(*a,**k): ...`                                 | Forgetting `@wraps` makes debugging / help text confusing, but no runtime error.                                                                |
| `functools.total_ordering`                                | Class decorator that fills in rich comparisons given `__eq__` and one ordering op. | `python\n@total_ordering\nclass Node: ...`                                                 | Must implement `__eq__` and **one** of `<, <=, >, >=`; wrong/partial implementation can give inconsistent ordering. ([Python documentation][1]) |
| `functools.singledispatch(func)`                          | Generic function based on first arg type.                                          | `python\n@singledispatch\ndef visit(x): ...`                                               | For DSA less common, but handy in visitor patterns; must register concrete types; works on runtime type of first arg only.                      |

[1]: https://docs.python.org/3/library/functools.html?utm_source=chatgpt.com "functools — Higher-order functions and operations on ... - Python"

# operator – operators & getters as functions
Great for sorting, key functions, and making code cleaner/faster vs lambdas.

| Method/Operation                                  | What it does                                            | Example                                               | Special errors / corner cases                                                                                        |
| ------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `operator.add(a, b)`                              | `a + b`.                                                | `operator.add(1, 2)  # 3`                             | Mirrors built-in operators; same errors (e.g. `TypeError` for incompatible types).                                   |
| `operator.sub(a, b)`                              | `a - b`.                                                | `operator.sub(5, 3)`                                  | –                                                                                                                    |
| `operator.mul(a, b)`                              | `a * b`.                                                | `operator.mul(2, 4)`                                  | –                                                                                                                    |
| `operator.truediv(a, b)`                          | `a / b`.                                                | `operator.truediv(5, 2)`                              | `ZeroDivisionError` if `b == 0`.                                                                                     |
| `operator.floordiv(a, b)`                         | `a // b`.                                               | `operator.floordiv(5, 2)`                             | Same as above.                                                                                                       |
| `operator.mod(a, b)`                              | `a % b`.                                                | `operator.mod(5, 2)`                                  | –                                                                                                                    |
| `operator.pow(a, b)`                              | `a ** b`.                                               | `operator.pow(2, 10)`                                 | Same caveats as `**`.                                                                                                |
| `operator.neg(a)` / `operator.pos(a)`             | Unary `-a` / `+a`.                                      | `operator.neg(3)`                                     | Depends on type implementing unary ops.                                                                              |
| `operator.eq(a, b)`, `ne`, `lt`, `le`, `gt`, `ge` | Comparison operators as functions.                      | `operator.lt(1, 2)  # True`                           | Good for building custom sort keys or predicates.                                                                    |
| `operator.itemgetter(*items)`                     | Return function that fetches element(s) by index/key.   | `get2 = itemgetter(2); get2([10,20,30])  # 30`        | For multiple keys, returns tuple; raises `IndexError`/`KeyError` same as indexing. ([GeeksforGeeks][1])              |
| `operator.attrgetter(*attrs)`                     | Return function that gets attribute(s).                 | `get_name = attrgetter('name'); get_name(obj)`        | Chained attributes like `'a.b.c'` allowed; missing attribute → `AttributeError`. ([Python documentation][2])         |
| `operator.methodcaller(name, *args, **kwargs)`    | Return function that calls named method on its operand. | `stripper = methodcaller('strip'); stripper('  hi ')` | If method doesn’t exist → `AttributeError`; any exception inside method propagates. ([Nkmk Note][3])                 |
| In-place ops: `iadd`, `isub`, ...                 | In-place versions of `+`, `-`, etc.                     | `operator.iadd(a_list, [4,5])`                        | Falls back to regular op if in-place not supported; mutates first arg if it is mutable and supports it (e.g. lists). |

[1]: https://www.geeksforgeeks.org/python/itemgetter-in-python/?utm_source=chatgpt.com "itemgetter () in Python - GeeksforGeeks"
[2]: https://docs.python.org/3/library/operator.html?utm_source=chatgpt.com "operator — Standard operators as functions — Python 3.14.1 documentation"
[3]: https://note.nkmk.me/en/python-operator-usage/?utm_source=chatgpt.com "The operator Module in Python: itemgetter, attrgetter, methodcaller"

# random – randomness for algorithms & tests
Useful for randomized quicksort/quickselect, test generation, etc.

| Method/Operation                                                     | What it does                                         | Example                        | Special errors / corner cases                                                                                        |
| -------------------------------------------------------------------- | ---------------------------------------------------- | ------------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| `random.seed(a=None)`                                                | Seed the PRNG (reproducible randomness).             | `random.seed(42)`              | Same seed → same sequence; if `a` is `None`, uses system entropy.                                                    |
| `random.random()`                                                    | Float in `[0.0, 1.0)`.                               | `x = random.random()`          | Never returns `1.0`.                                                                                                 |
| `random.randint(a, b)`                                               | Random int in **inclusive** range `[a, b]`.          | `random.randint(1, 6)`         | `ValueError` if `a > b`.                                                                                             |
| `random.randrange(start, stop[, step])`                              | Like `range`, but returns one random element.        | `random.randrange(0, 10, 2)`   | Same constraints as `range` (e.g. non-zero step, proper ordering) or `ValueError`.                                   |
| `random.uniform(a, b)`                                               | Float in `[a, b]` or `[b, a]` (inclusive endpoints). | `random.uniform(1.0, 2.0)`     | Endpoints may be returned; distribution is continuous.                                                               |
| `random.choice(seq)`                                                 | Random element from non-empty sequence.              | `random.choice([1,2,3])`       | `IndexError` if sequence empty.                                                                                      |
| `random.choices(population, weights=None, k=1)`                      | Return list of `k` elements with replacement.        | `random.choices([1,2,3], k=5)` | For large `k`, items may repeat; weights must be non-negative.                                                       |
| `random.sample(population, k)`                                       | Choose `k` distinct elements (without replacement).  | `random.sample(range(10), 3)`  | `ValueError` if `k > len(population)` (except for sets where population can be treated specially in newer versions). |
| `random.shuffle(x)`                                                  | In-place shuffle of a mutable sequence.              | `random.shuffle(lst)`          | `x` must be mutable and indexable; use `random.sample` for immutables.                                               |
| `random.getrandbits(k)`                                              | Integer with `k` random bits.                        | `random.getrandbits(32)`       | `k` must be non-negative; big `k` → big int.                                                                         |
| `random.betavariate`, `gammavariate`, `gauss`, `normalvariate`, etc. | Continuous distributions for simulations.            | `random.gauss(0, 1)`           | For most DSA prep you rarely need these; beware of floating precision.                                               |
| `random.randbytes(n)` (3.9+)                                         | Return `n` random bytes.                             | `random.randbytes(16)`         | Not cryptographically secure; for security use `secrets` module.                                                     |

# dataclasses – lightweight data containers (great for nodes)
Extremely handy for defining tree nodes, graph nodes, states with minimal boilerplate.

| Method/Operation                          | What it does                                                                | Example                                                                | Special errors / corner cases                                                                                                                    |                 |                                                                                                                                                                        |
| ----------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `@dataclass(...)`                         | Decorator to auto-generate `__init__`, `__repr__`, `__eq__`, ordering, etc. | ```python\n@dataclass\nclass Node:\n    val: int\n    left: 'Node      | None'=None\n    right: 'Node                                                                                                                     | None'=None\n``` | Options: `order=True` adds comparisons; `frozen=True` makes instances immutable; `slots=True` reduces memory. Misusing `frozen` with mutation → `FrozenInstanceError`. |
| `dataclasses.field(...)`                  | Customize a single field (default, repr, compare, etc.).                    | `children: list[int] = field(default_factory=list)`                    | Using `default=[]` for mutables is a classic bug; use `default_factory` instead.                                                                 |                 |                                                                                                                                                                        |
| Auto-generated methods                    | `__init__`, `__repr__`, `__eq__`, optionally ordering methods.              | `a == b`, `sorted(nodes)`                                              | Ordering only if `order=True`; equality based on fields, not identity.                                                                           |                 |                                                                                                                                                                        |
| `asdict(instance)`                        | Deep-convert dataclass instance to dict.                                    | `asdict(node)`                                                         | Recurses into nested dataclasses, lists, tuples, dicts; behaves like a **deep copy** of those structures. Can be expensive. ([GeeksforGeeks][1]) |                 |                                                                                                                                                                        |
| `astuple(instance)`                       | Like `asdict` but as tuple.                                                 | `astuple(node)`                                                        | Also deep-recursive by default; uses `tuple_factory` if provided. ([Stack Overflow][2])                                                          |                 |                                                                                                                                                                        |
| `replace(instance, **changes)`            | Return a new instance with some fields changed.                             | `node2 = replace(node, val=42)`                                        | Shallow copy then override; nested objects reused.                                                                                               |                 |                                                                                                                                                                        |
| `is_dataclass(obj)`                       | Check if object or class is a dataclass.                                    | `is_dataclass(Node)` / `is_dataclass(node)`                            | Returns `True` also for instances.                                                                                                               |                 |                                                                                                                                                                        |
| `make_dataclass(name, fields, **options)` | Dynamically create a dataclass type.                                        | `python\nPoint = make_dataclass('Point', ['x','y'])\np = Point(1,2)\n` | Fields can be `(name, type, field_spec)` tuples; useful for meta-programming or contests where you build quick struct types.                     |                 |                                                                                                                                                                        |

[1]: https://www.geeksforgeeks.org/python/data-classes-in-python-set-6-interconversion-to-and-from-other-datatypes/?utm_source=chatgpt.com "Data Classes in Python | Set 6 (interconversion to and from other ..."
[2]: https://stackoverflow.com/questions/51802109/why-is-dataclasses-astuple-returning-a-deepcopy-of-class-attributes?utm_source=chatgpt.com "python - Why is dataclasses.astuple returning a deepcopy of class ..."


